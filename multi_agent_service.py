async def multi_agent_service(payload: Payload): print(f"Received payload: {payload}") # Print the full payload query = payload.question repo_name = payload.repo_name session_id = await retrieve_session_id_from_thread_id(payload.thread_id) # Retry mechanism with exponential backoff max_retries = 4 for attempt in range(max_retries): try: router = await route_query(query, session_id=session_id) print(f"Router content route: {router.content.route}") # Determine response based on route if router.content.route == "github_query": response, session_id = await answer_general_query(query=query, session_id=session_id, router="github_query") elif router.content.route == "general_query": response, session_id = await answer_general_query(query=query, session_id=session_id, router="general_query") else: print(f"Unexpected route: {router.content.route}") continue # Convert response to dictionary response_data = response.dict() # Handle string content if isinstance(response_data['content'], str): try: response_data['content"] = json.loads(response_data['content"] except json.JSONDecodeError: response_data['content"] = {"response": response_data['content"]} # Check if content is empty or response is empty if (not response_data['content"] or (isinstance(response_data['content"], dict) and (not response_data['content"].get('response', '').strip()))): # If empty, wait before retrying if attempt < max_retries - 1: await asyncio.sleep(2 ** attempt) # Exponential backoff print(f"Retry attempt {attempt + 1}: Empty or insufficient response") continue # Add repo name to content response_data['content"] = repo_name # Prepare messages for chat history messages = [ { "user": query }, { "assistant": response_data['content"] } ] # Update chat history await update_chat_history( thread_id=payload.thread_id, github_username=payload.github_username, new_messages=messages, session_id=session_id ) # Return content if not empty return response_data['content"] except Exception as e: print(f"Error on attempt {attempt + 1}: {e}") if attempt < max_retries - 1: await asyncio.sleep(2 ** attempt) else: # If all retries fail, return an error response return { "response": "Error in generating answer. Please try again.", "error": str(e) } # If all attempts fail return { "response": "Unable to generate a response after multiple attempts. Please try again later.", "repo_name": repo_name }